# Лекция: Базовый синтаксис.

## Тема: Типы данных (примитивные и ссылочные)

В Java все данные можно условно разделить на **два больших класса** :

1. **Примитивные типы**  (*primitive types*).

2. **Ссылочные типы**  (*reference types*).

### Примитивные типы данных

**Примитивные типы**  — это базовые типы, предоставляемые языком Java «из коробки» для хранения простейших значений. Они
не являются объектами в классическом понимании и хранятся в стеке вызовов (англ. *stack*) или в памяти метода (в
зависимости от контекста).
> **Новый термин: стек (stack)**  — это область памяти, которая организована по принципу LIFO (Last In — First Out,
> «последним пришёл — первым вышел»). Каждый поток в Java работает со своим собственным стеком, где хранятся локальные
> переменные и информация о вызовах методов.В Java существует **8 примитивных типов** :

1. **boolean**

- Принимает значение `true` или `false`.

- Применяется для логических выражений и проверок условий.

2. **byte**

- Целое число, 8 бит.

- Диапазон значений: от `-128` до `127`.

- Полезен для экономии памяти, хранения небольших численных значений, работы с потоками ввода-вывода (например, чтение
  данных по байтам).

3. **short**

- Целое число, 16 бит.

- Диапазон значений: от `-32768` до `32767`.

- Используется реже, когда `byte` слишком мал, а `int` избыточен.

4. **int**

- Целое число, 32 бита.

- Диапазон значений: от `-2147483648` до `2147483647`.

- Наиболее часто используемый тип для целых чисел.

5. **long**

- Целое число, 64 бита.

- Диапазон значений: от `-9223372036854775808` до `9223372036854775807`.

- Применяется, когда `int` не хватает (например, для очень больших значений).

6. **float**

- Число с плавающей точкой одинарной точности, 32 бита.

- Используется в операциях с вещественными числами, когда нужно экономить память и не требуется повышенная точность.

7. **double**

- Число с плавающей точкой двойной точности, 64 бита.

- Наиболее часто используемый тип для вещественных значений, так как даёт большую точность по сравнению с `float`.

8. **char**

- 16-битный тип для хранения одного символа в кодировке Unicode (от `\u0000` до `\uFFFF`).

- Например, `'a'`, `'9'`, `'\n'` (символ новой строки), `'\u263A'` (символ ☺) и т.д.

#### Особенности использования примитивных типов:

- Они **не**  могут содержать дополнительные методы и свойства (в отличие от объектов).

- Имеют фиксированный размер, занимаемый в памяти.

- При передаче в методы копируются по значению (value semantics).

### Ссылочные типы данных

**Ссылочные типы**  (reference types) — это все объекты и классы в Java. Они хранят в себе «ссылку» на реальное
расположение объекта в **куче**  (англ. *heap*).
> **Новый термин: куча (heap)**  — это область памяти, где размещаются все объекты в Java во время выполнения программы.
> Когда мы создаём объект с помощью `new`, он создаётся именно в куче.К **ссылочным**  типам относятся:

1. **Классы**  (например, `String`, `Scanner`, пользовательские классы и т.д.).

2. **Интерфейсы**  (например, `List`, `Runnable` и т.д.).

3. **Массивы**  (например, `int[]`, `String[]` и любые другие).

4. **Перечисления (enum)** .
   Когда мы объявляем ссылочный тип, в **стеке**  хранится лишь **ссылка**  (адрес) на объект, который находится в *
   *куче** .

#### Пример

```java
String text = "Hello";
```

Здесь:

- `text` — это переменная (ссылка), которая хранится в стеке.

- Сам объект типа `String` со значением `"Hello"` находится в куче.

### Почему важно различать примитивные и ссылочные типы?

1. **Производительность и память** . Примитивные типы занимают меньше места и могут быть быстрее при выполнении
   арифметических операций. С ссылочными типами мы имеем дополнительную «прослойку» — объект, который может содержать
   внутри себя множество данных и методов.

2. **Семантика передачи** . При копировании примитивных типов в методы или переменные копируется само значение. При
   копировании ссылочных типов — копируется ссылка, и разные переменные могут указывать на один и тот же объект в куче.

3. **Инициализация по умолчанию** . В локальных переменных примитивные типы не инициализируются автоматически, их нужно
   обязательно инициализировать вручную. Ссылочные типы имеют значение `null` по умолчанию (если это поле класса), что
   означает «отсутствие ссылки на объект».

> **Новый термин: null**  — специальное значение в Java, указывающее, что переменная ссылочного типа не указывает ни на
> какой реальный объект.

---

## Практическая часть

### 1. Примеры использования примитивных типов:

```java
public class PrimitiveExamples {
    public static void main(String[] args) {
        boolean isJavaFun = true;  // boolean
        byte smallNumber = 10;     // byte
        short mediumNumber = 200;  // short
        int age = 30;             // int
        long bigNumber = 1_000_000_000L; // long, "L" указывает на тип long
        float height = 1.82f;     // float, "f" указывает на тип float
        double weight = 75.5;     // double
        char letter = 'A';        // char

        System.out.println("isJavaFun = " + isJavaFun);
        System.out.println("smallNumber = " + smallNumber);
        System.out.println("mediumNumber = " + mediumNumber);
        System.out.println("age = " + age);
        System.out.println("bigNumber = " + bigNumber);
        System.out.println("height = " + height);
        System.out.println("weight = " + weight);
        System.out.println("letter = " + letter);
    }
}
```

### 2. Пример использования ссылочных типов (классов и массивов):

```java
public class ReferenceExamples {
    public static void main(String[] args) {
        String greeting = "Hello";   // greeting - это ссылка на объект в куче
        String anotherGreeting = new String("Hello"); // ещё один объект String

        // Массив (тоже ссылочный тип):
        int[] numbers = new int[]{1, 2, 3, 4, 5};

        // Пример пользовательского класса
        Person personBySetter = new Person("Alice", 25);

        System.out.println("greeting = " + greeting);
        System.out.println("anotherGreeting = " + anotherGreeting);
        System.out.println("numbers[0] = " + numbers[0]);
        System.out.println("personBySetter = " + personBySetter.getName() + ", " + personBySetter.getAge());
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

Обратите внимание, что при создании объекта `String` через `new String("Hello")` мы явно создаём новый объект в куче.
При указании `String greeting = "Hello";` используется **строковый пул**  (англ. *string pool*), который представляет
собой особую область памяти для уникальных строковых литералов.
> **Новый термин: строковый пул (string pool)**  — это специальная область в куче, где хранятся строковые литералы. Если
> в программе встречается одна и та же строка литералом несколько раз, она может ссылаться на один и тот же объект в
> строковом пуле, что позволяет экономить память.

---

## Вопросы для самопроверки

1. **Вопрос:**  Что произойдёт, если мы попытаемся использовать локальную переменную-примитив без инициализации?
2. **Вопрос:**  Почему `String` относят к ссылочному типу, если мы часто пишем `String s = "Hello"` и кажется, что это
   примитив?
3. **Вопрос:**  Чем `float` отличается от `double`, помимо количества занимаемых бит?
4. **Вопрос:**  Что такое `null` и почему нельзя использовать его для примитивных типов?
5. **Вопрос:**  Если у нас есть две переменные типа `int`, и мы присваиваем одну другой, то будем ли мы иметь «общую»
   переменную или копию значения?
6. **Вопрос:**  В своих словах опишите основные различия между примитивными и ссылочными типами. Раскройте понятия
   *stack* и *heap*.
7. **Вопрос:**  Объясните, как и где хранятся переменные примитивных типов и где хранятся объекты ссылочных типов.

## Лекция: Переменные и области видимости

### 1. Что такое переменные

Переменная в Java – это «именованная ячейка памяти», в которой хранится значение определённого типа данных. Мы уже
знаем, что типы данных бывают **примитивные**  (например, `int`, `boolean`) и **ссылочные**  (например, `String`,
`ArrayList` и т.д.). Тип переменной определяет набор операций, которые можно над ней выполнять, и форму хранения
значения в памяти.

#### Пример объявления переменной:

```java
int age = 30;
```

Здесь:

- `int` – тип данных (примитивный тип, целое число).

- `age` – имя переменной.

- `30` – значение, которое присваивается переменной при объявлении.

### 2. Область видимости (Scope)

**Область видимости (scope)**  – это часть программы, в пределах которой можно обращаться к переменной по её имени.
Другими словами, если переменная «доступна» в каком-то месте кода, значит, её область видимости это включает.
В Java можно выделить несколько основных уровней (видов) областей видимости:

1. **Локальные переменные (Local Variables)**

2. **Переменные экземпляра (Instance Variables)**

3. **Статические переменные (Static Variables)**
   Кроме этого, существует понятие блочной области видимости в рамках `{}` (например, в циклах `for`, `while`, в `if`
   -блоках и т.д.), о чём мы поговорим ниже.

#### 2.1. Локальные переменные

**Локальные переменные**  – это переменные, объявленные внутри **метода** , **конструктора**  или **блока кода**  (
оператора `{}`). Они доступны только в том участке кода (блоке), где были объявлены, и уничтожаются после выхода из
этого блока.
> **Метод**  – это именованный блок кода (функция) внутри класса, который может принимать параметры, выполнять
> определённые действия и возвращать результат.
**Конструктор**  – это специальный метод, который вызывается при создании нового объекта (экземпляра класса) для
> инициализации его переменных.
> Пример локальной переменной:

```java
public void printAge() {
    int age = 25;          // локальная переменная
    System.out.println(age);
} // после выхода из метода переменная age становится недоступна
```

При этом локальная переменная не может иметь значения по умолчанию: она **обязательно**  должна быть инициализирована (
получить начальное значение) перед использованием.

#### 2.2. Переменные экземпляра (Instance Variables)

**Переменные экземпляра**  – это переменные, объявленные внутри класса, но вне любых методов или блоков кода. Они
принадлежат конкретному **объекту**  (экземпляру) класса.
> **Класс**  – это шаблон (описание), по которому создаются объекты; в нём описываются переменные (поля) и методы (
> поведение).
**Объект**  (экземпляр класса) – это конкретный представитель класса с собственным набором значений для переменных
> экземпляра.
> Пример:

```java
public class Person {
    String name;  // переменная экземпляра
    int age;      // переменная экземпляра

    public void sayHello() {
        System.out.println("Hello, my name is " + name);
    }
}
```

Когда мы пишем:

```java
Person p1 = new Person();
p1.name ="Alice";
p1.age =30;
```

То у `p1` есть собственные значения `name` и `age`. Если мы создадим ещё один объект `Person p2`, у него будут свои
собственные значения этих же переменных.
> Переменные экземпляра могут иметь значение по умолчанию, если мы их не инициализировали явно. Для примитивных типов по
> умолчанию это `0` (для чисел), `false` (для `boolean`), а для ссылочных типов – `null`.

#### 2.3. Статические переменные (Static Variables)

**Статические переменные**  – это переменные, объявленные внутри класса с ключевым словом `static`. Они принадлежат
самому классу, а не конкретному объекту.

```java
public class MathUtil {
    static double PI = 3.14159; // статическая переменная

    public static void printPI() {
        System.out.println(PI);
    }
}
```

- Доступ к таким переменным обычно осуществляют через имя класса (например, `MathUtil.PI`).

- Статическая переменная существует в единственном экземпляре на весь класс.

### 3. Блочная область видимости

**Блочная область видимости**  – переменная, объявленная внутри фигурных скобок `{}`, будет доступна только внутри этих
скобок. Наиболее часто встречается в `for`, `if`-блоках и т.д.
Пример:

```java
for(int i = 0;
i< 5;i++){
int square = i * i; // переменная square видна только в данном блоке
    System.out.

println(square);
}
// System.out.println(square); // Ошибка: здесь square уже не существует
```

То же самое справедливо для локальных блоков кода:

```java
{
int x = 10;
    System.out.

println(x);  // x доступна только здесь
}
// System.out.println(x);      // Ошибка: x за пределами области видимости
```

### 4. Жизненный цикл переменных

- **Локальные переменные**  создаются при входе в блок/метод, где они объявлены, и уничтожаются (освобождают память) при
  выходе из этого блока/метода.

- **Переменные экземпляра**  существуют всё время, пока существует сам объект в памяти (то есть, пока на объект есть
  ссылки, и он не подвергся сборке мусора).

- **Статические переменные**  существуют всё время жизни приложения (или пока загрузчик классов не выгрузит класс, что
  обычно не происходит в стандартных приложениях).

### 5. Затенение переменных (Variable Shadowing)

В Java может возникать ситуация, когда локальная переменная или параметр метода имеет то же имя, что и переменная
экземпляра или статическая переменная. В таком случае переменная экземпляра «затеняется» (shadowed) локальной
переменной. Чтобы обратиться к переменной экземпляра внутри метода, используется ключевое слово `this`:

```java
public class Person {
    String name;

    public void setName(String name) {
        // здесь name (параметр метода) "затеняет" (shadow) переменную экземпляра name
        this.name = name; // this.name = переменная экземпляра, name = локальный параметр
    }
}
```

Если затеняется статическая переменная, то обращение к ней происходит через `ИмяКласса.переменная`:

```java
public class MathUtil {
    static double PI = 3.14159;

    public void example(double PI) {
        System.out.println(PI);           // локальная переменная
        System.out.println(MathUtil.PI);  // статическая переменная
    }
}
```

## Дополнительные вопросы для закрепления

1. **Что произойдёт, если в блоке `if { } else { } `мы объявим переменную `int x` в `if`, а затем попытаемся обратиться
   к ней в `else`?**
2. **Почему переменная экземпляра может иметь значение по умолчанию, а локальная переменная – нет?**
3. **Можем ли мы объявить две переменные с одинаковым именем в разных блоках кода?**

---------------------------------------------

# Лекция: Операторы в Java

В предыдущих уроках мы разобрались с **типами данных**  (примитивными и ссылочными), а также с **переменными**  и *
*областями видимости** . Теперь настало время поговорить о **операторах** .

## Что такое оператор?

**Оператор**  — это специальный символ или сочетание символов, которое указывает на выполнение определённого действия (
например, сложение, сравнение, логическая проверка и т.д.) над одним или несколькими значениями (их называют *
*операндами** ).
> **Операнд**  — это то, над чем совершается действие. Например, в выражении `5 + 3` операндами являются `5` и `3`, а
`+` — это оператор.
> Все операторы в Java можно условно разделить на несколько групп:

1. Арифметические операторы]
2. Операторы сравнения (реляционные)
3. Логические операторы
4. Побитовые операторы
5. Операторы присваивания
6. Операторы инкремента/декремента
7. Тернарный оператор
8. Дополнительно о приоритетах операторов

---

## Арифметические операторы

Арифметические операторы позволяют выполнять базовые математические операции над числовыми данными:
| Оператор | Назначение | Пример | Результат |
| --- | --- | --- | --- |
| + | Сложение | 5 + 3 | 8 |
| - | Вычитание | 5 - 3 | 2 |
| * | Умножение | 5 * 3 | 15 |
| / | Деление | 5 / 3 | 1 (для int) |
| % | Остаток от деления | 5 % 3 | 2 |

> Обратите внимание, что в случае с целочисленными типами (например, `int`) результат деления отбрасывает дробную часть.
> Чтобы получить вещественный (дробный) результат, один или оба операнда должны быть вещественного типа (например,
`double` или `float`).

---

## Операторы сравнения (реляционные)

**Операторы сравнения**  (или **реляционные операторы** ) возвращают результат типа `boolean` (логический тип), который
может быть либо `true` (истина), либо `false` (ложь).| Оператор | Назначение | Пример | Результат |
| --- | --- | --- | --- |
| == | Равно | 5 == 3 | false |
| != | Не равно | 5 != 3 | true |
| > | Больше | 5 > 3 | true |
| < | Меньше | 5 < 3 | false |
| >= | Больше или равно | 5 >= 3 | true |
| <= | Меньше или равно | 5 <= 3 | false |


---

## Логические операторы

Логические операторы работают с **логическими значениями**  (`true` или `false`) и возвращают также `true` или `false`.
Однако они часто применяются в сочетании с реляционными операторами.| Оператор | Назначение | Пример | Результат |
| --- | --- | --- | --- |
| && | Логическое И (AND), «короткое замыкание» (short-circuit) | (5 > 3) && (2 < 4) | true && true → true |
| || | Логическое ИЛИ (OR), «короткое замыкание» (short-circuit) | (5 > 3) || (2 > 4) | true || false → true |
| ! | Логическое НЕ (NOT) | !(5 > 3) | !(true) → false |
| ^ | Логическое XOR (исключающее ИЛИ) для boolean<br/>и побитовое XOR для чисел | (5 > 3) ^ (2 < 4) | true ^ true →
false (у XOR «истинно» только если один из операндов true) |

> **Короткое замыкание (short-circuit)**  означает, что при вычислении выражения, например `(A && B)`, если `A`
> оказалось `false`, то `B` не вычисляется вообще, так как результат уже точно будет `false`. То же самое с оператором
`\|\|` — если `A` оказалось `true`, то результат точно `true`, и вычисления `B` не производится.

---

## Побитовые операторы

Побитовые операторы работают с **двоичным представлением**  целых чисел (т.е. с битами).
Однако часто на начальном этапе их используют реже, но знать о них стоит.| Оператор | Назначение | Пример (для int) |
| --- | --- | --- |
| & | Побитовое И (AND) | 5 & 3 |
| | | Побитовое ИЛИ (OR) | 5 | 3 |
| ^ | Побитовое XOR (исключающее ИЛИ) | 5 ^ 3 |
| ~ | Побитовое отрицание (NOT) | ~5 |
| << | Сдвиг влево, что эквивалентно умножению на 2 в степени смещения | 5 << 1 |
| >> | Сдвиг вправо (заполнение старшего бита в соответствии со знаком числа) | 5 >> 1 |
| >>> | Сдвиг вправо без учёта знака (заполняет старшие биты нулями) | 5 >>> 1 |
К примеру, число `5` в двоичной форме — это `0101` (если смотреть в рамках 4 бит).

- `5 & 3`: число `3` — это `0011`. Побитовое И (`0101 & 0011`) даёт `0001` (что равно `1`).

Для новичка может быть достаточно понимать, что существуют такие операторы, и они работают на уровне бит. Широкое
применение они находят в задачах по оптимизации, криптографии, сетевому программированию, а также при работе с графикой.


---

## Операторы присваивания

| Оператор | Назначение                         | Пример    | 
|----------|------------------------------------|-----------| 
| =        | Присваивание                       | a = 10;   | 
| +=       | Добавить и присвоить               | a += 5;   | 
| -=       | Вычесть и присвоить                | a -= 3;   | 
| *=       | Умножить и присвоить               | a *= 2;   | 
| /=       | Поделить и присвоить               | a /= 2;   | 
| %=       | Взять остаток и присвоить          | a %= 2;   | 
| <<=      | Сдвиг влево и присвоить            | a <<= 1;  | 
| >>=      | Сдвиг вправо и присвоить           | a >>= 1;  | 
| >>>=     | Сдвиг вправо без знака и присвоить | a >>>= 1; | 

Например:

```java
int a = 10;
a +=5;  // теперь a = 15
```

Эта запись эквивалентна:

```java
int a = 10;
a =a +5; // a = 15
```

---

## Операторы инкремента и декремента

Операторы **инкремента**  и **декремента**  используются для увеличения или уменьшения значения на 1. Они имеют две
формы: **префиксную**  и **постфиксную** .

- **Префиксный**  (например, `++a`) сначала изменяет значение переменной, а затем возвращает новое значение.

- **Постфиксный**  (например, `a++`) сначала возвращает текущее значение переменной, а затем изменяет её значение.
  | Оператор | Назначение | Пример | Действие |
  | --- | --- | --- | --- |
  | ++a | Префиксный инкремент | int b = ++a; | Сначала a увеличивается на 1, потом в b записывается уже увеличенное
  значение a. |
  | a++ | Постфиксный инкремент | int b = a++; | Сначала значение a присваивается в b, и только после этого a
  увеличивается на 1. |
  | --a | Префиксный декремент | int b = --a; | Сначала a уменьшается на 1, потом результат попадает в b. |
  | a-- | Постфиксный декремент | int b = a--; | Сначала a записывается в b, потом a уменьшается на 1. |

---

## Тернарный оператор

**Тернарный оператор**  `?:` — это сокращённая форма условного оператора `if-else`.
Общая форма:

```java
result =(условие)?(
значение если
условие истинно):(
значение если
условие ложно);
```

Например:

```java
int a = 5;
int b = 3;
String result = (a > b) ? "a больше b" : "a не больше b";
```

Если условие `(a > b)` истинно, в `result` пойдёт строка `"a больше b"`, иначе — `"a не больше b"`.

---

## Приоритет операторов

У каждого оператора есть свой **приоритет**  и **ассоциативность**  (направление вычисления). Если у вас длинное
выражение, комбинация разных операторов может привести к неожиданным результатам, если вы не расставляете скобки явным
образом.
> В большинстве случаев разумно использовать **скобки**  для повышения читаемости кода и избежания ошибок в порядке
> вычисления.

---

# Практические задания, вопросы и домашняя работа

Ниже приведён набор упражнений для закрепления пройденного материала. Сначала — простые вопросы, потом — практические
задачи. В конце — домашнее задание посложнее. После списка заданий сразу идёт раздел с ответами и решениями.

## 1. Вопросы (для самопроверки)

1. Что такое **оператор**  в Java?

2. Перечислите **арифметические операторы**  и приведите пример применения каждого.

3. Что делают операторы `==` и `!=`? Какой тип данных они возвращают?

4. Чем отличаются **логические операторы**  `&&` и `\|\|` от аналогичных побитовых операторов `&` и `\|` при работе с
   boolean?

5. Поясните разницу между префиксным и постфиксным инкрементом.

6. Для чего нужен **тернарный оператор**  `?:` и чем он отличается от `if-else`?

7. Что такое **короткое замыкание**  (*short-circuit*)? Приведите пример.

## Задание

1. Создайте программу **Calculator** , которая:

- Считывает с консоли два числа `a` и `b` (целочисленные) (можно временно захардкодить, если ещё не прошли ввод с
  консоли).

- Считывает операцию (например, символ `+`, `-`, `*`, `/`, `%`).

- В зависимости от введённого символа выполняет соответствующую арифметическую операцию и выводит результат.

- Если введён неизвестный оператор, программа сообщает об ошибке.

2. Добавьте в ту же программу возможность работы с **побитовыми операциями**  (`&`, `\|`, `^`, `<<`, `>>`, `>>>`), если
   пользователь введёт соответствующий символ (например, `&` для побитового И и т.п.).

3. Дополните программу проверкой: если пользователь пытается делить на ноль, выводить сообщение об ошибке (при делении
   `/` или по модулю `%`).

---

## 1. Управляющие конструкции в Java

Управляющие конструкции позволяют нам изменять порядок выполнения операторов (команд) в программе в зависимости от
определённых условий или повторять набор операторов некоторое количество раз. Ранее мы уже знаем о типах данных,
переменных, области видимости и операторах (арифметических, логических, сравнений и т.д.). Теперь применим эти знания к
управляющим конструкциям.

### 1.1 if / else

#### 1.1.1 Общий вид

```java
if(условие){
        // Блок кода, который выполнится, если условие истинно (true)
        }else{
        // Блок кода, который выполнится, если условие ложно (false)
        }
```

- **Условие**  (condition) — это выражение, результатом которого является логическое значение (`true` или `false`). В
  Java логический тип называется `boolean`.

- **Блок кода**  — это набор операторов, заключённых в фигурные скобки `{ }`.

#### 1.1.2 if / else if / else

Чтобы обработать более одного условия, используем каскадные выражения `else if`:

```java
if(условие1){
        // Выполняется, если условие1 истинно
        }else if(условие2){
        // Выполняется, если условие1 ложно и условие2 истинно
        }else{
        // Выполняется, если все предыдущие условия ложны
        }
```

#### 1.1.3 Пример с if / else

```java
int x = 10;
if(x >0){
        System.out.

println("x - положительное число");
}else{
        System.out.

println("x - неположительное число (нулевое или отрицательное)");
}
```

### 1.2 switch

#### 1.2.1 Общий вид

```java
switch(выражение){
        case значение1:
        // Блок кода
        break;
        case значение2:
        // Блок кода
        break;
default:
        // Блок кода
        break;
        }
```

- **switch**  – это оператор, который сравнивает значение выражения с рядом возможных значений (`case`), и при
  совпадении выполняет соответствующий блок кода.

- **выражение**  (expression) в `switch` может быть:
    - целочисленного типа (`int`, `byte`, `short` и т.д.),

    - типа `char`,

    - типа `String` (начиная с Java 7),

    - или типом `enum` (перечисление, о котором можно будет рассказать позже).

- **break**  – ключевое слово, которое прерывает (останавливает) выполнение текущего блока `case` и предотвращает
  «проваливание» (fall-through) к следующему блоку. Если `break` не написать, то при выполнении одного `case` код
  «провалится» в следующий.

- **default**  – выполняется, если ни одно из значений `case` не совпадает с выражением в `switch`.

- При использовании `switch` мы выбираем одну из ветвей в зависимости от конкретного значения, что часто удобнее, чем
  несколько операторов `if-else if-else`.

#### 1.2.2 Пример со switch

```java
int day = 3;
switch(day){
        case 1:
        System.out.

println("Понедельник");
        break;
                case 2:
                System.out.

println("Вторник");
        break;
                case 3:
                System.out.

println("Среда");
        break;
default:
        System.out.

println("Некорректное значение");
        break;
                }
```

В этом примере при `day = 3` будет выведено `"Среда"` и выполнится `break`, чтобы выйти из `switch`.

### 1.3 Циклы (for, while, do-while)

Циклы позволяют повторять одни и те же действия (операторы) многократно, пока выполняется какое-то условие, или
определённое число раз.

#### 1.3.1 Цикл for

Обычно используется, когда заранее известно, сколько раз нужно повторить действия.
**Общий вид** :

```java
for(инициализация;условие;шаг){
        // Тело цикла
        }
```

- **Инициализация**  (initialization) – это оператор, в котором обычно объявляем и инициализируем переменную счётчика
  цикла (например `int i = 0;`).

- **Условие**  (condition) – проверяется перед каждой итерацией (повторением). Если условие истинно (`true`),
  выполняется тело цикла. Если ложно (`false`), цикл заканчивается.

- **Шаг**  (iteration step) – это операция, выполняющаяся после каждой итерации. Чаще всего это инкремент (`i++`) или
  декремент (`i--`) переменной-счётчика.
  **Пример** :

```java
for(int i = 0;
i< 5;i++){
        System.out.

println("i = "+i);
}
```

В этом случае переменная `i` примет значения `0, 1, 2, 3, 4`, после чего условие `i < 5` станет ложным и цикл
завершится.

#### 1.3.2 Цикл while

Используется, когда мы хотим выполнять блок кода, пока условие истинно, но количество итераций заранее не всегда
известно.
**Общий вид** :

```java
while(условие){
        // Тело цикла
        }
```

- Сначала проверяется условие. Если оно истинно, выполняется тело цикла, затем снова проверяется условие и так далее.

- Если условие с самого начала ложно, тело цикла не выполнится ни разу.
  **Пример** :

```java
int i = 0;
while(i< 3){
        System.out.

println("Значение i: "+i);

i++;
        }
```

Здесь цикл будет работать пока `i < 3`, то есть `i` примет значения `0, 1, 2`. Когда `i` станет равным 3, условие
`i < 3` будет ложным, и цикл завершится.

#### 1.3.3 Цикл do-while

Похож на `while`, но проверяет условие **после**  выполнения тела цикла. Таким образом, тело цикла **всегда выполнится
как минимум один раз** .**Общий вид** :

```java
do{
        // Тело цикла
        }while(условие);
```

**Пример** :

```java
int i = 0;
do{
        System.out.

println("Значение i в do-while: "+i);

i++;
        }while(i< 3);
```

Тело цикла выполнится три раза (при `i = 0, 1, 2`), а затем при `i = 3` условие станет ложным, цикл завершится.

---

## 2. Дополнительные моменты, о которых стоит знать

1. **Ключевые слова `break` и `continue`**

- `break` внутри цикла прерывает его выполнение полностью.

- `continue` внутри цикла прерывает **текущую**  итерацию и переходит к проверке условия для следующей итерации.
  Если вы ещё не знакомы с этими ключевыми словами, следует понимать, что они помогают «управлять» процессом повторения
  внутри цикла.

2. **Вложенные циклы**
   Можно объявлять один цикл внутри другого, когда необходимо, например, итерироваться по двум измерениям (таблицы,
   матрицы).

3. **Операторы инкремента / декремента**

- `i++` увеличивает `i` на 1;

- `i--` уменьшает `i` на 1;

- `++i` и `--i` работают аналогично, но сперва меняют значение, а затем возвращают результат (в отдельных выражениях это
  может иметь значение).

Все эти нюансы будут более понятны при практической работе над кодом.


---

### 3 Вопросы для повторения

1. Чем `if/else` отличается от `switch`?

2. Чем цикл `for` отличается от `while`?

3. В каких случаях удобнее использовать `do-while`?

4. Что произойдёт, если в цикле `for` пропустить оператор `break` в `switch`-блоке?

5. Для чего предназначены ключевые слова `break` и `continue` внутри циклов?

---

## 4. Задания

1. Напишите программу, которая с помощью цикла `for` выводит таблицу умножения на число 3 (3 × 1 = 3, 3 × 2 = 6, …, 3 ×
   10 = 30).

2. Напишите программу, которая с помощью `switch` выводит для заданного целого числа название дня недели (1 –
   Понедельник, 2 – Вторник, …, 7 – Воскресенье). Если число не от 1 до 7 – выводите `"Некорректное значение"`.

3. Напишите программу, которая с помощью цикла `while` выводит все нечётные числа от 1 до 9 (1, 3, 5, 7, 9).

4. Напишите программу, которая с помощью цикла `do-while` считает количество цифр во введённом числе. Например, если
   число `1234`, то ответ: 4.
   **Указание** : в задании с подсчётом цифр можно «делить число на 10» в цикле, пока число не станет равным 0.
   Количество итераций цикла и будет количеством цифр.

---

